<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Как написать проверку орфографии. Питер Норвиг</title>
<style type="text/css">
/*<![CDATA[*/
HTML { text-align: center }
BODY { color: #515458; font: 87.5%/150% Arial, Geneva, Helvetica, sans-serif; text-align: left; margin: 3em auto; padding: 0; width: 600px }
CODE, PRE { font-size: 110% }
DIV.c2 { text-align: left }
DIV.code { background: #FFFFE1; font: "Courier New"; margin: 0 -30px 1em; padding: 30px}
P.c3 { font-weight: bold }
.perev { font:  "Courier New" }
SPAN { color: #000; font: "Courier New" }
span.c5 { color: blue }
span.c4 { color: red }
.s0 { color: #808080 }
.s1 { color: #7F007F; font: "Verdana" }
.s2 { color: #007F7F }
.s4 { font: "Courier New"; color: #007F00; font-size: 10pt }
.s5 { font-weight: bold; color: #00007F }
.s9 { font-weight: bold; color: #007F7F }
.s10 { color: #808080 }
.s12 { color: #7F7F7F }
TABLE { background: #FFF; border: 1px solid #CCCFD3; border-spacing: 0; border-collapse: collapse; empty-cells: show; line-height: normal; text-align: left; margin: 0 auto 1.5em; width: 100%}
	CAPTION { font-weight: bold; text-align: left; margin: 0 auto; padding-bottom: .6em}
	THEAD { background: #E1E3E7}
    	THEAD TH { border-bottom: 1px solid #CCCFD3}
	TD, TH { border-right: 1px solid #CCCFD3; font-size: 100%; font-weight: normal; vertical-align: top; padding: 10px}
/*]]>*/
</style>
</head>
<body>
<h1>Как написать проверку орфографии («спеллчекер»)</h1>
<h4>(c) <a href="http://norvig.com">Питер Норвиг</a>. Перевод: <a href="http://gmdidro.googlepages.com">Петров Александр</a></h4>
<h4>Кто такой Питер Норвиг</h4>
<a href="http://en.wikipedia.org/wiki/Peter_Norvig">Питер Норвиг</a> американец, возглавляет исследовательское отделение компании Google. Почетный член и советник Американской ассоциации Искусственного интеллекта. Написал книгу «<a href="http://en.wikipedia.org/wiki/Artificial_Intelligence:_A_Modern_Approach">Искусственный интеллект: современный подход</a>» в соавторстве со Стюартом Расселом. Основные статьи Норвига посвящены проблемам искусственного интеллекта и компьютерной лингвистики. Он является одним из авторов языка <a href="http://en.wikipedia.org/wiki/JScheme">JScheme</a>. Он также является автором известного эссе «<a href="http://www.norvig.com/21-days.html">Научитесь программировать за десять лет</a>», переведенного на разные языки мира.
<p class="c3">И так, приступим...</p>
<p>На прошлой неделе два моих друга (Дин и Билл) независимо друг от друга сказали мне, что они поражены работой Гугловского корректора орфографии. Как здорово и быстро он работает, говорили они. Напишите в строке поиска, например «праферка» и Гугл любезно поправит вас – «<span class="c4">Возможно, вы имели в виду:</span> <span class="c5"><i>проверка</i></span>». <span class="perev">(прим.перев. Стоит, конечно, <a href="http://sm.aport.ru/scripts/template.dll?That=std&amp;r=%EF%F0%EE%EA%F1%E8+%F1%E5%F0%E2%E5%F0">отметить</a>, что все ломается, если захотеть)</span>. Поисковики Microsoft’a и Yahoo работают тоже хорошо. Меня же удивило то, что изначально я думал, что Дин и Билл будучи специалистами в области математики обратили внимание на отличную работу проверки орфографии в Гугле потому, что осознавали те проблемы, которые возникают при статистической обработке текста и при решении таких задач, как проверка орфографии. Однако как оказалось оба моих друга математикой не занимались, и вообщем-то моё предположение оказалось не верным.</p>
<p>Я подумал, что многим будет интересно узнать, как реализуются орфографические корректоры. Не думаю, что стоит полностью описывать детали реализации корректоров, которые используются в Гугле или Yahoo, но планка, которую я поставил для своего корректора достаточно высока – корректор, код которого занимает чуть меньше страницы, будет иметь точность около 80/90 % и будет работать со скоростью 10 слов в секунду. И так вот он – 21 строка Пайтоновского (Python 2.5) кода – и это полностью законченный орфографический проверяльщик:</p>
<div class="code"><span class="s5">import</span> re<span class="s10">,</span> collections<br />
<span class="s5">def</span> <span class="s9">words</span><span class="s10">(</span>text<span class="s10">):</span> <span class="s5">return</span> re<span class="s10">.</span>findall<span class="s10">(</span><span class="s4">'[a-z]+'</span><span class="s10">,</span> text<span class="s10">.</span>lower<span class="s10">())</span><br />
<span class="s5">def</span> <span class="s9">train</span><span class="s10">(</span>features<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> model <span class="s10">=</span> collections<span class="s10">.</span>defaultdict<span class="s10">(</span><span class="s5">lambda</span><span class="s10">:</span> <span class="s2">1</span><span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">for</span> f <span class="s5">in</span> features<span class="s10">:</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> model<span class="s10">[</span>f<span class="s10">]</span> <span class="s10">+=</span> <span class="s2">1</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">return</span> model<br />
NWORDS <span class="s10">=</span> train<span class="s10">(</span>words<span class="s10">(</span>file<span class="s10">(</span><span class="s4">'big.txt'</span><span class="s10">).</span>read<span class="s10">()))</span><br />
alphabet <span class="s10">=</span> <span class="s4">'abcdefghijklmnopqrstuvwxyz'</span><br />
<span class="s5">def</span> <span class="s9">edits1</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> n <span class="s10">=</span> len<span class="s10">(</span>word<span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> set<span class="s10">(</span><span class="s0">&nbsp;</span><span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">1</span><span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">)]</span> <span class="s10">+</span> <span class="s0">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s1"># deletion</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">1</span><span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">2</span><span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">-</span><span class="s2">1</span><span class="s10">)]</span> <span class="s10">+</span> <span class="s0">&nbsp;</span><span class="s1">&nbsp;# transposition</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>c<span class="s10">+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">1</span><span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">)</span> <span class="s5">for</span> c <span class="s5">in</span> alphabet<span class="s10">]</span> <span class="s10">+</span> <span class="s0">&nbsp;</span><span class="s1">&nbsp;&nbsp;# alteration</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>c<span class="s10">+</span>word<span class="s10">[</span>i<span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">+</span><span class="s2">1</span><span class="s10">)</span> <span class="s5">for</span> c <span class="s5">in</span> alphabet<span class="s10">])</span> <span class="s0">&nbsp; &nbsp;</span><span class="s1"># insertion</span><br />
<span class="s5">def</span> <span class="s9">known_edits2</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> set<span class="s10">(</span>e2 <span class="s5">for</span> e1 <span class="s5">in</span> edits1<span class="s10">(</span>word<span class="s10">)</span> <span class="s5">for</span> e2 <span class="s5">in</span> edits1<span class="s10">(</span>e1<span class="s10">)</span> <span class="s5">if</span> e2 <span class="s5">in</span> NWORDS<span class="s10">)</span><br />
<span class="s5">def</span> <span class="s9">known</span><span class="s10">(</span>words<span class="s10">):</span> <span class="s5">return</span> set<span class="s10">(</span>w <span class="s5">for</span> w <span class="s5">in</span> words <span class="s5">if</span> w <span class="s5">in</span> NWORDS<span class="s10">)</span><br />
<span class="s5">def</span> <span class="s9">correct</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> candidates <span class="s10">=</span> known<span class="s10">([</span>word<span class="s10">])</span> <span class="s5">or</span> known<span class="s10">(</span>edits1<span class="s10">(</span>word<span class="s10">))</span> <span class="s5">or</span> known_edits2<span class="s10">(</span>word<span class="s10">)</span> <span class="s5">or</span> <span class="s10">[</span>word<span class="s10">]</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> max<span class="s10">(</span>candidates<span class="s10">,</span> key<span class="s10">=</span><span class="s5">lambda</span> w<span class="s10">:</span> NWORDS<span class="s10">[</span>w<span class="s10">])</span>
<p><br />
</p>
</div>
<p>Использовать этот код нужно следующим образом –</p>
<div class="code"><span class="s10">&gt;&gt;&gt;</span> correct<span class="s10">(</span><span class="s4">'speling'</span><span class="s10">)</span><br />
<span class="s4">'spelling'</span><br />
<span class="s10">&gt;&gt;&gt;</span> correct<span class="s10">(</span><span class="s4">'korrecter'</span><span class="s10">)</span><br />
<span class="s4">'corrector'</span></div>
<br />
<h2>Реальная математика – немного теории вероятностей</h2>
Как же работают эти 21 строка кода? Для начала немного теории. Пусть дано слово, будем пытаться отыскать слово, в котором с наибольшей вероятностью исправлены допущенные ошибки (если ошибок нет, то таким словом будет данное). Разумеется, мы не сможем гарантировать 100% исправления всех ошибок. (Например, если нам дано слово «пак», то правильным будет слово «паз» или «парк» ?), именно поэтому мы используем вероятностный (или другими словами стохастический) подход. Будем говорить, что мы пытаемся выбрать такое слово <i>c</i> из всех возможных слов-исправлений, что вероятность появления именно слова <i>c</i> при данном слове <i>w</i> будет максимальна:
<blockquote>argmax<sub><i>c</i></sub> P(<i>c</i>|<i>w</i>)</blockquote>
Согласно <a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%91%D0%B0%D0%B9%D0%B5%D1%81%D0%B0">теореме Байеса</a> - выражение, записанное выше, эквивалентно следующему выражению:
<blockquote>argmax<sub><i>c</i></sub> P(<i>w</i>|<i>c</i>) P(<i>c</i>) / P(<i>w</i>)</blockquote>
Поскольку P(<i>w</i>) одинакова для всех <i>c</i> мы можем отбросить P(<i>w</i>), что даст нам:
<blockquote>argmax<sub><i>c</i></sub> P(<i>w</i>|<i>c</i>) P(<i>c</i>)</blockquote>
В этом выражении присутствуют три части. Справа налево:
<ol>
<li>P(<i>c</i>) – вероятность появления слова <i>c</i> (частотность употребления <i>c</i>). Эта вероятность обусловлена самим языком (точнее моделью языка). Иначе говоря, P(<i>c</i>) определяет как часто <i>c</i> встречается в текстах на русском [английском\…] языке. P(«превед») будет достаточно высока, тогда как P(«благоденствовать») будет меньше, а P(«ыгввыцшы») будет около нуля.</li>
<li>P(<i>w</i>|<i>c</i>) – вероятность того, что автор опечатался и написал <i>w</i>, хотя имел в виду <i>c</i>. По сути дела эта вероятность обусловлена частотностью тех или иных ошибок в языке (и называется моделью ошибок языка).</li>
<li>argmax<sub><i>c</i></sub> – оператор, перебирающий все возможные <i>c</i> в поиске наиболее (вероятнее всего) подходящего из них (т.е. данный оператор ищет такое допустимое <i>c</i>, которе максимизирует условную вероятность появления <i>w</i> при данном <i>c</i>).</li>
</ol>
Может возникнуть очевидный вопрос – зачем мы преобразовали простое выражение «argmax<sub><i>c</i></sub> P(<i>c</i>|<i>w</i>)» с помощью какого-то Байеса в более сложное выражение, в котором используются аж две языковые модели, вместо одной? Дело в том, что P(<i>c</i>|<i>w</i>) учитывает в себе сразу обе языковых модели, поэтому очевидно, что проще выделить эти модели и работать с ними по отдельности. Предположим у нас есть слово с опечаткой – «езать», это может быть как «ехать», так и «резать». Для какого из исправлений P(<i>c</i>|<i>w</i>) будет максимально ? Оба исправления имеют примерно одинаковую частотность в русском языке. Хорошо допустим «х» и «з» близко расположены в русской раскладке клавиатуры и это повышает вероятность варианта «ехать», но это не повод, чтоб отбрасывать «резать», ведь «е» и «р» тоже близки. Поэтому лучше не рассматривать P(<i>c</i>|<i>w</i>) как единую величину, ибо нам приходится учитывать и частность исправления <i>c</i> и вероятность исправления <i>c</i> для данной опечатки в <i>w</i>. Удобнее работать с этими двумя вероятностями по отдельности.
<p>Теперь мы готовы к тому, чтоб посмотреть, как же работает 21-строчный орфографический корректор. Начнем с P(<i>c</i>). Мы читаем большой текстовый файл, <a href="http://norvig.com/big.txt">big.txt</a>, в котором записан миллион слов. Содержание этого файла – это несколько книг из проекта <a href="http://www.gutenberg.org/wiki/Main_Page">Гутенберг</a>, а также списки самых часто встречающихся слов из <a href="http://en.wiktionary.org/wiki/Wiktionary:Frequency_lists">Wiktionary</a> и <a href="http://www.kilgarriff.co.uk/bnc-readme.html">British National Corpus</a>. (Вообще-то в самолете, когда я писал эту статью, у меня в моем ноутбуке были ли лишь рассказы о Шерлоке Холмсе, остальные тексты я добавил позже и перестал добавлять их, когда увидел, что новый текст не улучшает характеристики программы. Я подробно остановлюсь на этом позже, когда мы будем оценивать реализованный корректор)</p>
<p>После того как мы загрузили наш файл, мы извлекаем отдельные слова из файла (используя функцию words, которая считает словом любую последовательность алфавитных символов и при этом является нечувствительной к регистру (words(“The”) -&gt; “the”; words(“Don’t”) -&gt; “don”,”t”.)) Затем мы обучаем нашу стохастическую модель. Это звучит неплохо, но реально, мы просто считаем сколько раз в файле встречается каждое слово. Именно это делает функция train. В коде это выглядит следующим образом:</p>
<div class="code"><span><span class="s5">def</span> <span class="s9">words</span><span class="s10">(</span>text<span class="s10">):</span> <span class="s5">return</span> re<span class="s10">.</span>findall<span class="s10">(</span><span class="s4">'[a-z]+'</span><span class="s10">,</span> text<span class="s10">.</span>lower<span class="s10">())</span><br />
<span class="s5">def</span> <span class="s9">train</span><span class="s10">(</span>features<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> model <span class="s10">=</span> collections<span class="s10">.</span>defaultdict<span class="s10">(</span><span class="s5">lambda</span><span class="s10">:</span> <span class="s2">1</span><span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">for</span> f <span class="s5">in</span> features<span class="s10">:</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp;</span> model<span class="s10">[</span>f<span class="s10">]</span> <span class="s10">+=</span> <span class="s2">1</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> model<br />
NWORDS <span class="s10">=</span> train<span class="s10">(</span>words<span class="s10">(</span>file<span class="s10">(</span><span class="s4">'big.txt'</span><span class="s10">).</span>read<span class="s10">()))</span></span></div>
Мы можем узнать сколько раз слово <i>w</i> встретилось в файле просто обратившись к таблице NWORDS: NWORDS[w]. Однако при таком подходе мы сталкиваемся с проблемой – что делать со словами, которых не было в файле. Было бы неправильным заявлять, что такие слова имеют вероятность 0, только потому, что они не присутствовали в нашей выборке. Вообще говоря, есть несколько решений данной проблемы. Сейчас мы выберем самое простое – будем считать, что мы «видели» любое слово хотя бы один раз, даже если этого слова не было в нашей файле. В статистике такой подход называется сглаживанием – мы как бы поднимаем провалы на графике распределения вероятностей нашей модели языка. При подсчете числа вхождений слов в файл мы используем collections.defaultdict (это обычный Пайтоновский словарь, т.е. это то, что в других языках иногда называют хэш-таблицей). В силу озвученных выше причин, все значения словаря инициализируются значением 1.
<p>Теперь обратим внимание на проблему перечисления всех возможных исправлений <i>c</i> для слова <i>w</i>. Часто говорят о расстоянии(edit distance) между двумя словами, имея при этом в виду число символов, которые надо изменить в одном из слов, чтоб слова стали идентичными. Изменением может быть удаление символа, транспозиция символов (когда символы меняются местами), замена одного символа другим или вставка нового символа. Ниже представлен код функции, которая возвращает все слова <i>c</i> для данного слова <i>w</i> с расстоянием в единицу:</p>
<div class="code"><span><span class="s5">def</span> <span class="s9">edits1</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> n <span class="s10">=</span> len<span class="s10">(</span>word<span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> set<span class="s10">(</span><span class="s0">&nbsp;</span><span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">1</span><span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">)]</span> <span class="s10">+</span> <span class="s0">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s1"># deletion</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">1</span><span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">]+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">2</span><span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">-</span><span class="s2">1</span><span class="s10">)]</span> <span class="s10">+</span> <span class="s0">&nbsp;</span><span class="s1"># transposition</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>c<span class="s10">+</span>word<span class="s10">[</span>i<span class="s10">+</span><span class="s2">1</span><span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">)</span> <span class="s5">for</span> c <span class="s5">in</span> alphabet<span class="s10">]</span> <span class="s10">+</span> <span class="s0">&nbsp;</span><span class="s1"># alteration</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s10">[</span>word<span class="s10">[</span><span class="s2">0</span><span class="s10">:</span>i<span class="s10">]+</span>c<span class="s10">+</span>word<span class="s10">[</span>i<span class="s10">:]</span> <span class="s5">for</span> i <span class="s5">in</span> range<span class="s10">(</span>n<span class="s10">+</span><span class="s2">1</span><span class="s10">)</span> <span class="s5">for</span> c <span class="s5">in</span> alphabet<span class="s10">])</span> <span class="s0">&nbsp;</span> <span class="s1"># insertion</span></span></div>
На выходе этой функции - множество слов(set). Для данного английского слова длины n существует n удалений, n-1 перестановок, 26n замен, 26(n+1) вставок, что в итоге дает нам 54n+25 вариантов. Например len(edits1(“something”)) вернет 494.
<p>Считается, что от 80% до 90% всех опечаток отстоят от оригинала на единицу (в смысле описанного выше расстояния). Как вскоре будет показано ниже, когда я взял множество слов с 270 ошибками, только 76% из них отстояло от правильных вариантов на расстояние 1. Возможно дело в сложности ошибок, которые попали в мою выборку но, в любом случае мне показалось, что стоит учитывать и ошибки с расстоянием 2. К счастью их учет реализуется очень просто – нужно применить функцию edits1 к своему же результату 1 раз.</p>
<div class="code"><span><span class="s5">def</span> <span class="s9">edits2</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> set<span class="s10">(</span>e2 <span class="s5">for</span> e1 <span class="s5">in</span> edits1<span class="s10">(</span>word<span class="s10">)</span> <span class="s5">for</span> e2 <span class="s5">in</span> edits1<span class="s10">(</span>e1<span class="s10">))</span></span></div>
<span class="perev">(прим.перев. Написать такой код не сложно, но боюсь, что для его исполнения в разумные сроки нам придется арендовать один из суперкомпьютеров NASA)</span> len(edits2(“something”)) дает 114324 вариантов. Однако edits2 обладает гораздо лучшим покрытием, чем edits1 – на моем тесте из 270 ошибок только 3 ошибки отстоят на расстояние большее чем 2. Таким образом, edits2 покрывает 98.9% всех ошибок, что вполне меня устраивает. Кроме того, поскольку мы не собираемся увеличивать расстояние находимых ошибок, мы можем немного оптимизировать наш код – мы можем сохранять только те варианты, которые ранее были сохранены в NWORDS:
<div class="code"><span><span class="s5">def</span> <span class="s9">known_edits2</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> set<span class="s10">(</span>e2 <span class="s5">for</span> e1 <span class="s5">in</span> edits1<span class="s10">(</span>word<span class="s10">)</span> <span class="s5">for</span> e2 <span class="s5">in</span> edits1<span class="s10">(</span>e1<span class="s10">)</span> <span class="s5">if</span> e2 <span class="s5">in</span> NWORDS<span class="s10">)</span></span></div>
Теперича known_edits2(“something”) возвращает множество всего из трех слов - { «smoothing», «something», «soothing»}, что несколько меньше чем 114324 слова, генерируемых функцией edits2. В результате мы получаем ускорение в 10%.
<p>И так нам осталось рассмотреть реализацию последней части нашей программы – модель ошибок или P(<i>w</i>|<i>c</i>). И вот тут-то меня подстерегали проблемы. Сидя в самолете, без интернета, я не знал, где б мне найти данные для обучения моей системы. Следуя зову своей интуиции, я решил использовать некоторые эвристики – мы с большей вероятностью можем ошибиться и заменить одну гласную на другую, тогда как замена двух согласных менее вероятна; ошибка в первой букве слова также имеет небольшие шансы на возникновение и т.д. Однако у меня не было фактов, не было результатов экспериментов, чтоб подтвердить мои догадки. Поэтому я поступил проще – я определил тривиальную модель ошибок, которая считает, что все известные слова с расстоянием в единицу от данного слова имеют большую вероятность стать опечаткой, чем слова с расстоянием в 2, но при этом они имеют бесконечно маленькую вероятность по сравнению с известными словами с расстоянием 0. Под известными словами я подразумевал слова из нашего файла (big.txt). Реализовать такую модель можно следующим образом –</p>
<div class="code"><span><span class="s5">def</span> <span class="s9">known</span><span class="s10">(</span>words<span class="s10">):</span> <span class="s5">return</span> set<span class="s10">(</span>w <span class="s5">for</span> w <span class="s5">in</span> words <span class="s5">if</span> w <span class="s5">in</span> NWORDS<span class="s10">)</span><br />
<span class="s5">def</span> <span class="s9">correct</span><span class="s10">(</span>word<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> candidates <span class="s10">=</span> known<span class="s10">([</span>word<span class="s10">])</span> <span class="s5">or</span> known<span class="s10">(</span>edits1<span class="s10">(</span>word<span class="s10">))</span> <span class="s5">or</span> known_edits2<span class="s10">(</span>word<span class="s10">)</span> <span class="s5">or</span> <span class="s10">[</span>word<span class="s10">]</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> max<span class="s10">(</span>candidates<span class="s10">,</span> key<span class="s10">=</span><span class="s5">lambda</span> w<span class="s10">:</span> NWORDS<span class="s10">[</span>w<span class="s10">])</span></span></div>
В начале функция correct строит множество возможных слов-исправлений. В это множество включаются известные слова, отстоящие от данного слова на минимальное расстояние. И как только такое множество будет построено, из него будет выбран элемент с максимальным значением P(<i>c</i>), которое, как мы помним, определяется в словаре NWORDS.
<h2>Оценка программы</h2>
Самое время оценить насколько хорошо работает наша программа. В полете я потестировал её на нескольких примерах и она с ними вполне справилась. После посадки, я сразу же загрузил словарь ошибок Роджера Миттона (Roger Mitton's <a href="http://ota.ahds.ac.uk/texts/0643.html">Birkbeck spelling error corpus</a>), который храниться в Оксфордском архиве. С помощью этого словаря я построил два тестовых примера. Первый я использовал в процессе тестирования программы при её разработке и настройке.
<p>Второй тест был моим окончательным тестом, в том смысле, что программу на этом тесте я запустил один раз и уже не мог улучшить результаты тестирования, изменяя программу как-либо, для того чтобы подогнать её под этот конкретный тест. Я часто так делаю – использую два тестовых примера. Это помогает мне не привязываться к конкретным входным данным. Ниже показаны два теста и программа тестировщик. Полный текст примеров и программы Вы можете найти здесь - <a href="http://norvig.com/spell.py">spell.py</a>.</p>
<div class="code">tests1 <span class="s10">=</span> <span class="s10">{ </span> <span class="s4">'access'</span><span class="s10">:</span> <span class="s4">'acess'</span><span class="s10">,</span> <span class="s4">'accessing'</span><span class="s10">:</span> <span class="s4">'accesing'</span><span class="s10">,</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span class="s4">'accommodation'</span><span class="s10">:</span> <span class="s4">'accomodation acommodation acomodation'</span><span class="s10">,</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span class="s4">'account'</span><span class="s10">:</span> <span class="s4">'acount'</span><span class="s10">,</span> <span class="s10">...}</span><br />
tests2 <span class="s10">=</span> <span class="s10">{ </span><span class="s4">'forbidden'</span><span class="s10">:</span> <span class="s4">'forbiden'</span><span class="s10">,</span> <span class="s4">'decisions'</span><span class="s10">:</span> <span class="s4">'deciscions descisions'</span><span class="s10">,</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="s4">'supposedly'</span><span class="s10">:</span> <span class="s4">'supposidly'</span><span class="s10">,</span> <span class="s4">'embellishing'</span><span class="s10">:</span> <span class="s4">'embelishing'</span><span class="s10">,</span> <span class="s10">...}</span><br />
<br />
<span class="s5">def</span> <span class="s9">spelltest</span><span class="s10">(</span>tests<span class="s10">,</span> bias<span class="s10">=</span><span class="s5">None</span><span class="s10">,</span> verbose<span class="s10">=</span>False<span class="s10">):</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">import</span> time<br />
<span class="s0">&nbsp; &nbsp;</span> n<span class="s10">,</span> bad<span class="s10">,</span> unknown<span class="s10">,</span> start <span class="s10">=</span> <span class="s2">0</span><span class="s10">,</span> <span class="s2">0</span><span class="s10">,</span> <span class="s2">0</span><span class="s10">,</span> time<span class="s10">.</span>clock<span class="s10">()</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">if</span> bias<span class="s10">:</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">for</span> target <span class="s5">in</span> tests<span class="s10">:</span> NWORDS<span class="s10">[</span>target<span class="s10">]</span> <span class="s10">+=</span> bias<br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">for</span> target<span class="s10">,</span>wrongs <span class="s5">in</span> tests<span class="s10">.</span>items<span class="s10">():</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">for</span> wrong <span class="s5">in</span> wrongs<span class="s10">.</span>split<span class="s10">():</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> n <span class="s10">+=</span> <span class="s2">1</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> w <span class="s10">=</span> correct<span class="s10">(</span>wrong<span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">if</span> w<span class="s10">!=</span>target<span class="s10">:</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> bad <span class="s10">+=</span> <span class="s2">1</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> unknown <span class="s10">+=</span> <span class="s10">(</span>target <span class="s5">not</span> <span class="s5">in</span> NWORDS<span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">if</span> verbose<span class="s10">:</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> <span class="s5">print</span> <span class="s4">'%r =&gt; %r (%d); expected %r (%d)'</span> <span class="s10">%</span> <span class="s10">(</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> wrong<span class="s10">,</span> w<span class="s10">,</span> NWORDS<span class="s10">[</span>w<span class="s10">],</span> target<span class="s10">,</span> NWORDS<span class="s10">[</span>target<span class="s10">])</span><br />
<span class="s0">&nbsp; &nbsp;</span> <span class="s5">return</span> dict<span class="s10">(</span>bad<span class="s10">=</span>bad<span class="s10">,</span> n<span class="s10">=</span>n<span class="s10">,</span> bias<span class="s10">=</span>bias<span class="s10">,</span> pct<span class="s10">=</span>int<span class="s10">(</span><span class="s2">100.</span> <span class="s10">-</span> <span class="s2">100.</span><span class="s10">*</span>bad<span class="s10">/</span>n<span class="s10">),</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span> unknown<span class="s10">=</span>unknown<span class="s10">,</span> secs<span class="s10">=</span>int<span class="s10">(</span>time<span class="s10">.</span>clock<span class="s10">()-</span>start<span class="s10">)</span> <span class="s10">)</span><br />
<span class="s0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><br />
<span class="s5">print</span> spelltest<span class="s10">(</span>tests1<span class="s10">)</span><br />
<span class="s5">print</span> spelltest<span class="s10">(</span>tests2<span class="s10">)</span> <span class="s1">## only do this after everything is debugged</span></div>
Результаты теста –
<div class="code"><span class="s10">{ </span><span class="s4">'bad'</span><span class="s10">:</span> <span class="s2">68</span><span class="s10">,</span> <span class="s4">'bias'</span><span class="s10">:</span> <span class="s5">None</span><span class="s10">,</span> <span class="s4">'unknown'</span><span class="s10">:</span> <span class="s2">15</span><span class="s10">,</span> <span class="s4">'secs'</span><span class="s10">:</span> <span class="s2">16</span><span class="s10">,</span> <span class="s4">'pct'</span><span class="s10">:</span> <span class="s2">74</span><span class="s10">,</span> <span class="s4">'n'</span><span class="s10">:</span> <span class="s2">270</span><span class="s10">}</span><br />
<span class="s10">{ </span><span class="s4">'bad'</span><span class="s10">:</span> <span class="s2">130</span><span class="s10">,</span> <span class="s4">'bias'</span><span class="s10">:</span> <span class="s5">None</span><span class="s10">,</span> <span class="s4">'unknown'</span><span class="s10">:</span> <span class="s2">43</span><span class="s10">,</span> <span class="s4">'secs'</span><span class="s10">:</span> <span class="s2">26</span><span class="s10">,</span> <span class="s4">'pct'</span><span class="s10">:</span> <span class="s2">67</span><span class="s10">,</span> <span class="s4">'n'</span><span class="s10">:</span> <span class="s2">400</span><span class="s10">}</span></div>
Итого: отладочный тест из 270 слов дал 74% верных «ответов» за 16 секунд, финальный тест показал 67% правильности за 26 секунд при 400 словах. И так, мы получили небольшую, простую и быструю программу, которая, однако, достаточно часто ошибается.
<h2>Совершенствование</h2>
Давайте прикинем как мы можем сделать нашу жизнь лучше… Или просто попробуем усовершенствовать нашу программу. Мы вновь обратимся к трем параметрам нашей вероятностной модели - P(<i>c</i>); P(<i>w</i>|<i>c</i>); и argmax<sub><i>c</i></sub> . Обратим внимание на те примеры, на которых наша программа ошибалась. А затем посмотрим, какие есть ещё факторы, кроме трех, выше перечисленных.
<ol>
<li>P(<i>c</i>) или модель языка. Можно выявить два источника ошибок в языковой модели. Во-первых и главных, это слова, не учтенные при обучении модели – т.е. неизвестные слова. В отладочном примере было 15 неизвестных слов или 5%, в финальном тесте 43 неизвестных слова или 11%. Вот несколько примеров работы функции spelltest при verbose=True :
<div class="code">correct<span class="s10">(</span><span class="s4">'economtric'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'economic'</span> <span class="s10">(</span><span class="s2">121</span><span class="s10">);</span> expected <span class="s4">'econometric'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'embaras'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'embargo'</span> <span class="s10">(</span><span class="s2">8</span><span class="s10">);</span> expected <span class="s4">'embarrass'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'colate'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'coat'</span> <span class="s10">(</span><span class="s2">173</span><span class="s10">);</span> expected <span class="s4">'collate'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'orentated'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'orentated'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">);</span> expected <span class="s4">'orientated'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'unequivocaly'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'unequivocal'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">);</span> expected <span class="s4">'unequivocally'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'generataed'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'generate'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">);</span> expected <span class="s4">'generated'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'guidlines'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'guideline'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">);</span> expected <span class="s4">'guidelines'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span></div>
Выше показаны результаты вызовов функции correct (в скобках указана частота встречаемости слова в обучающей выборке, т.е. NWORDS) и слова, которые как ожидалось должна вернуть функция (в скобках указаны их частота встречаемости в обучающей выборке). Эти результаты показывают, что если система не знает такого слова как «econometric», она не способна исправить опечатку в слове «economtric». Мы можем уменьшить количество таких ошибок, расширив обучающую выборку, включив в неё больше разнообразных слов, однако при этом мы повысим вероятность того, что система не сможет выбрать подходящее для данной конкретной опечатки слово из-за большого разнообразия слов. Обратите внимание, что выше в последних четырех строках приведены примеры, в которых указаны слова, которые встречаются в словаре нашей системы, но с измененными окончаниями. Таким образом, нам может потребоваться система, которая может сказать, что окончание “-ed” корректно для глаголов, а “-s” для существительных.
<p>Вторым источником ошибок в нашей модели является неправильное распределение вероятностей в обучающей выборке – слово, которое часто встречается в выборке, может относительно редко встречаться в повседневной лексике. Я должен отметить, что я не смог найти примеры, в которых именно эта причина являлась главной и основной причиной ошибочной работы системы, обычно большее влияние оказывали другие факторы.</p>
<p>Давайте посмотрим, насколько сильно объем и репрезентативность обучающей выборки влияет на результаты работы системы. Для этого мы немного поколдуем над нашей тестировочной программой. Будем дублировать в обучающей выборке корректно написанное слово - будем делать 1 дубль этого слова, 10 дублей и т.д. Этим мы имитируем рост объема обучающей выборки и при этом она остается корректной. Эта идея реализована с помощью параметра bias функции spelltest.</p>
<p>Ниже представлены результаты работы этой функции при изменении данного параметра:</p>
<table align="center">
<tr>
<td>Bias</td>
<td>Dev.</td>
<td>Test</td>
</tr>
<tr>
<td>0</td>
<td>74%</td>
<td>67%</td>
</tr>
<tr>
<td>1</td>
<td>74%</td>
<td>70%</td>
</tr>
<tr>
<td>10</td>
<td>76%</td>
<td>73%</td>
</tr>
<tr>
<td>100</td>
<td>82%</td>
<td>77%</td>
</tr>
<tr>
<td>1000</td>
<td>89%</td>
<td>80%</td>
</tr>
</table>
На обоих наших тестовых вариантах мы способны достичь 80-90% правильности работы системы. Следовательно, мы можем предположить, что если бы у нас была достаточно хорошая вероятностная модель языка, то программа работала бы лучше. С другой стороны, это достаточно самонадеянное предположение, поскольку, как уже было сказано, увеличивая объем обучающей выборки, мы можем добавить в словарь системы слова, которые приведут к новым ошибкам.
<p>Другим путем разрешения проблемы неизвестных слов является разрешение системе выводить слова, которых ещё нет в её словаре. К примеру, на вход системы подается слово «electroencephalographicallz», нам-то с вами очевидно, что нужно поменять последнею «z» на “y”, но система-то этого не знает, кроме того слова «electroencephalographically» по странному (почти мифическому) стечению обстоятельств не оказалось в словаре нашей системы. Мы можем позволить системе вывести это слово, если расширить стохастическую модель языка слогами или суффиксами (нпр., «-ally»), или что проще, расширить модель не на уровне слогов или суффиксов, а последовательностями из 2, 3, 4 букв.</p>
</li>
<li>P(<i>w</i>|<i>c</i>) или модель ошибок. Как уже было сказано, используемая в системе модель ошибок тривиальна – чем меньше расстояние между словами, тем меньше ошибка. Это вызывает некоторые проблемы, проиллюстрированные примерами ниже. Во-первых, часто функция correct возвращает предполагаемое исправление, отстоящее от ошибочного слова на 1 символ, тогда как реальное исправление(исправление с высокой частотностью) отстоит на 2 символа.
<div class="code">correct<span class="s10">(</span><span class="s4">'reciet'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'recite'</span> <span class="s10">(</span><span class="s2">5</span><span class="s10">);</span> expected <span class="s4">'receipt'</span> <span class="s10">(</span><span class="s2">14</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'adres'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'acres'</span> <span class="s10">(</span><span class="s2">37</span><span class="s10">);</span> expected <span class="s4">'address'</span> <span class="s10">(</span><span class="s2">77</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'rember'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'member'</span> <span class="s10">(</span><span class="s2">51</span><span class="s10">);</span> expected <span class="s4">'remember'</span> <span class="s10">(</span><span class="s2">162</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'juse'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'just'</span> <span class="s10">(</span><span class="s2">768</span><span class="s10">);</span> expected <span class="s4">'juice'</span> <span class="s10">(</span><span class="s2">6</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'accesing'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'acceding'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">);</span> expected <span class="s4">'assessing'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span></div>
В данных примерах, нам хотелось бы, чтобы изменение “d” на “c” классифицировалось системой как «более ошибочное», чем скажем замена буквы “d” на “dd”. Кроме того, встречаются случаи, когда при одинаковом расстоянии правильного слова и неправильного слова от слова с опечаткой, система выбирает неправильное, с точки зрения пользователя, слово.
<div class="code">correct<span class="s10">(</span><span class="s4">'thay'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'that'</span> <span class="s10">(</span><span class="s2">12513</span><span class="s10">);</span> expected <span class="s4">'they'</span> <span class="s10">(</span><span class="s2">4939</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'cleark'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'clear'</span> <span class="s10">(</span><span class="s2">234</span><span class="s10">);</span> expected <span class="s4">'clerk'</span> <span class="s10">(</span><span class="s2">26</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'wer'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'her'</span> <span class="s10">(</span><span class="s2">5285</span><span class="s10">);</span> expected <span class="s4">'were'</span> <span class="s10">(</span><span class="s2">4290</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'bonas'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'bones'</span> <span class="s10">(</span><span class="s2">263</span><span class="s10">);</span> expected <span class="s4">'bonus'</span> <span class="s10">(</span><span class="s2">3</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'plesent'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'present'</span> <span class="s10">(</span><span class="s2">330</span><span class="s10">);</span> expected <span class="s4">'pleasant'</span> <span class="s10">(</span><span class="s2">97</span><span class="s10">)</span></div>
<p>Как и ранее, нам бы хотелось, чтоб система воспринимала замену «a» на «e» в «they» как менее значительное изменение, чем замена “y” на “t”. Нас сколько менее значимым должно быть это изменение? Как минимум в 2.5 раза, чтобы перекрыть вероятностное преимущество слова “that” над “they”.</p>
<p>Очевидно, что наша модель ошибок нуждается в совершенствовании. Руководствуясь здравым смыслом, мы могли бы в ручную присвоить более высокие приоритеты удвоению буквы (т.е. уменьшить значимость такого изменения) или изменению одной гласной на другую (по сравнению с произвольной заменой букв), одним словом, нам требуется лучшая модель, лучшая обучающая выборка по ошибкам. Причем объем такой выборки, содержащей значительное число распространенных описок, также должен быть значительным. Например, если мы хотим рассмотреть вероятность замены одной буквы другой, учитывая при этом две соседние буквы по обеим сторонам от заменяемой, то нам придется рассмотреть 26^6 или около 300 миллионов символов. Причем очевидно, что нам захочется рассмотреть несколько примеров таких замен, и, следовательно, грубо говоря, нам нужно будет рассмотреть около 10 миллиардов символов. Обратите внимание на связь между моделью языка и моделью ошибок. Текущая версия системы имеет очень простую модель ошибок (чем меньше расстояние между <i>c</i> и <i>w</i> , тем больший приоритет отдается <i>c</i>), что отрицательно влияет на модель языка. Мы не можем бесконтрольно добавлять новые слова в обучающую выборку. Причина этого в том, что если до добавления нового слова программа выбирала в качестве исправления слово, отстоящее на расстояние 2, то после добавления, новое слово может как бы скрыть этот правильный (наиболее употребительный с точки зрения модели языка) вариант, если новое слово имеет расстояние 1. Т.е. модель ошибок влияет (отрицательно) на модель языка. Имея более качественную(разборчивую) модель ошибок, мы могли бы безбоязненно расширять обучающую выборку для модели языка. Вот несколько примеров, иллюстрирующих описанную ситуацию:</p>
<div class="code">correct<span class="s10">(</span><span class="s4">'wonted'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'wonted'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">);</span> expected <span class="s4">'wanted'</span> <span class="s10">(</span><span class="s2">214</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'planed'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'planed'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">);</span> expected <span class="s4">'planned'</span> <span class="s10">(</span><span class="s2">16</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'forth'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'forth'</span> <span class="s10">(</span><span class="s2">83</span><span class="s10">);</span> expected <span class="s4">'fourth'</span> <span class="s10">(</span><span class="s2">79</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'et'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'et'</span> <span class="s10">(</span><span class="s2">20</span><span class="s10">);</span> expected <span class="s4">'set'</span> <span class="s10">(</span><span class="s2">325</span><span class="s10">)</span></div>
Слова «wonted», «planed», «et» имеют не высокую частотность согласно модели языка (2, 2 и 20 соответственно), и они скрывают более часто употребительные слова из-за выбранной нами модели ошибок.</li>
<li>argmax<sub><i>c</i></sub> или оператор выбора возможных слов-исправлений. Наша программа перебирает все возможные слова-исправления на расстоянии 2 от слова, подозреваемого на наличие опечатки. В отладочном тестовом примере только 3 из 270 слов отстоят на расстояние более 2, но в финальном тесте таких слов 23 (из 400). Вот они:
<pre>
purple perpul
curtains courtens
minutes muinets

successful sucssuful
hierarchy heiarky
profession preffeson
weighted wagted
inefficient ineffiect
availability avaiblity
thermawear thermawhere
nature natior
dissension desention
unnecessarily unessasarily
disappointing dissapoiting
acquaintances aquantences
thoughts thorts
criticism citisum
immediately imidatly
necessary necasery
necessary nessasary
necessary nessisary
unnecessary unessessay
night nite
minutes muiuets
assessing accesing
necessitates nessisitates
</pre>
Возможно, нам стоит расширить модель ошибок, увеличив допустимое расстояние между словом с опечаткой и словом-исправлением до 3. Видимо слова из примеров выше были бы исправлены, если бы мы разрешили вставлять гласную после другой гласной или заменять одну гласную на другую гласную или менять местами близкие согласные такие как «c» и «s».</li>
<li>Рассмотрим четвертый (и самый результативный) способ улучшения работы нашей программы: изменить интерфейс (сигнатуру) функции correct так, чтобы она могла учитывать контекст, в который входит то или иное слово, подозреваемое на опечатку. Сейчас correct обрабатывает одно слово за один раз. Абсолютно очевидно, что во многих случаях принять решение, основываясь лишь на одном слове, крайне тяжело. Например:
<div class="code">correct<span class="s10">(</span><span class="s4">'where'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'where'</span> <span class="s10">(</span><span class="s2">123</span><span class="s10">);</span> expected <span class="s4">'were'</span> <span class="s10">(</span><span class="s2">452</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'latter'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'latter'</span> <span class="s10">(</span><span class="s2">11</span><span class="s10">);</span> expected <span class="s4">'later'</span> <span class="s10">(</span><span class="s2">116</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'advice'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'advice'</span> <span class="s10">(</span><span class="s2">64</span><span class="s10">);</span> expected <span class="s4">'advise'</span> <span class="s10">(</span><span class="s2">20</span><span class="s10">)</span></div>
Мы не можем определенно сказать должен ли вызов correct('where') вернуть нам 'where' или 'were'. Однако если бы вызов функции выглядел бы следующим образом - ('They where going') , то вероятность выбора 'where' могла бы быть выше. (У нас бы появилась дополнительная информация, позволяющая обосновать выбор того или иного варианта) Причём такая стратегия помогла бы нам и в более нетривиальных случаях –
<div class="code">correct<span class="s10">(</span><span class="s4">'hown'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'how'</span> <span class="s10">(</span><span class="s2">1316</span><span class="s10">);</span> expected <span class="s4">'shown'</span> <span class="s10">(</span><span class="s2">114</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'ther'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'the'</span> <span class="s10">(</span><span class="s2">81031</span><span class="s10">);</span> expected <span class="s4">'their'</span> <span class="s10">(</span><span class="s2">3956</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'quies'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'quiet'</span> <span class="s10">(</span><span class="s2">119</span><span class="s10">);</span> expected <span class="s4">'queries'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'natior'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'nation'</span> <span class="s10">(</span><span class="s2">170</span><span class="s10">);</span> expected <span class="s4">'nature'</span> <span class="s10">(</span><span class="s2">171</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'thear'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'their'</span> <span class="s10">(</span><span class="s2">3956</span><span class="s10">);</span> expected <span class="s4">'there'</span> <span class="s10">(</span><span class="s2">4973</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'carrers'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'carriers'</span> <span class="s10">(</span><span class="s2">7</span><span class="s10">);</span> expected <span class="s4">'careers'</span> <span class="s10">(</span><span class="s2">2</span><span class="s10">)</span></div>
Должны ли мы выбрать вариант 'there' при исправлении слова 'thear' или мы должны выбрать вариант 'their'. Мы не можем обосновать выбор, основываясь на одном слове, но если бы мы работали с предложением - correct('There's no there thear') , то выбор стал бы очевиден. Для того чтобы построить модель, которая бы учитывала контекст, нам потребуется ещё более большая обучающая выборка <span class="perev">(прим.перев. и похоже нам опять придется вспомнить о суперкомпьютерах)</span>. К счастью мы можем воспользоваться услугами Google, который предоставляет доступ к <a href="http://googleresearch.blogspot.com/2006/08/all-our-n-gram-are-belong-to-you.html">базе данных частотности</a> слов, в которой учитывается контекст длиной в пять слов, а сама БД составлялась на основе триллиона слов.
<p>Я уверен, что орфографический корректор пытающийся достичь 90% точности обязательно должен использовать контекст. Думаю, мы с вами займемся этим как-нибудь на досуге…</p>
</li>
<li>Мы можем несколько повысить точность нашей системы, если будем более тщательно относиться к обучающей выборке. При обучении использовался файл в миллион слов, однако никто не бился об заклад, что среди этих слов нет ошибочно написанных слов, не опечаток и т.д. По хорошему нужно бы найти их и исправить… Тестируя систему на своих тестовых вариантах, я обнаружил по крайней мере три случая, когда тест пытался убедить меня, что моя программа ошиблась, хотя я был уверен, что не прав тест:
<div class="code">correct<span class="s10">(</span><span class="s4">'aranging'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'arranging'</span> <span class="s10">(</span><span class="s2">20</span><span class="s10">);</span> expected <span class="s4">'arrangeing'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'sumarys'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'summary'</span> <span class="s10">(</span><span class="s2">17</span><span class="s10">);</span> expected <span class="s4">'summarys'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'aurgument'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'argument'</span> <span class="s10">(</span><span class="s2">33</span><span class="s10">);</span> expected <span class="s4">'auguments'</span> <span class="s10">(</span><span class="s2">1</span><span class="s10">)</span></div>
Кроме того, следует определиться с каким диалектом английского языка мы собираемся работать. Следующие три ошибки как раз связаны с различиями Американского и Британского английских языков:
<div class="code">correct<span class="s10">(</span><span class="s4">'humor'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'humor'</span> <span class="s10">(</span><span class="s2">17</span><span class="s10">);</span> expected <span class="s4">'humour'</span> <span class="s10">(</span><span class="s2">5</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'oranisation'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'organisation'</span> <span class="s10">(</span><span class="s2">8</span><span class="s10">);</span> expected <span class="s4">'organization'</span> <span class="s10">(</span><span class="s2">43</span><span class="s10">)</span><br />
correct<span class="s10">(</span><span class="s4">'oranised'</span><span class="s10">)</span> <span class="s10">=&gt;</span> <span class="s4">'organised'</span> <span class="s10">(</span><span class="s2">11</span><span class="s10">);</span> expected <span class="s4">'organized'</span> <span class="s10">(</span><span class="s2">70</span><span class="s10">)</span></div>
</li>
<li>Наконец мы можем улучшить саму реализацию нашей программы, оптимизировав её и повысив скорость выполнения. Скажем, мы можем реализовать её на компилируемом, а не интерпретируемом языке программирования. Можем использовать другой контейнер для строк, специализированный под хранение и сравнение строк. Можем кэшировать результаты наших проверок и т.д. Только в этом деле всегда нужно помнить о том, что перед тем как оптимизировать что-либо нужно убедиться, что именно этот участок кода является узким местом программы.</li>
</ol>
<h2>Список литературы</h2>
<ul>
<li><a href="http://www.dcs.bbk.ac.uk/~roger/spellchecking.html">Статья</a> Роджера Миттона, посвященная корректорам орфографии.</li>
<li>Журафски и Мартин дают обзор поднимаемых в данной статье вопросов в своей <a href="http://www.cs.colorado.edu/~martin/slp.html">статье</a>  «Обработка лингвистической информации».</li>
<li>Маннинг и Щутзе <a href="http://nlp.stanford.edu/fsnlp/">рассматривают</a> стохастические языковые модели.</li>
<li>На сайте проекта <a href="http://aspell.net/">aspell</a> размещено много интересных материалов, в том числе тестовые примеры, которые вроде как будут получше тех, что я использовал.</li>
</ul>
<h2>Спеллчекеры на других языках программирования</h2>
После того как я опубликовал эту статью, появилось несколько реализаций корректора орфографии на других языках программирования. Возможно, кому-то будет интересно сравнить реализации на разных языках.
<ul>
<li>Erlang: by <a href="http://www.pixzone.com/blog/223/spell-corrector-aka-google-suggest-in-erlang-first-part/">Federico Feroldi</a></li>
<li>F#: by <a href="http://cs.hubfs.net/forums/thread/3085.aspx">Sebastian G</a></li>
<li>Haskell: by <a href="http://pithekos.net/brainwave/">Grzegorz</a></li>
<li>Perl: by <a href="http://www.riffraff.info/2007/5/10/a-spell-corrector-in-perl6-part-1">riffraff</a></li>
<li>Rebol: by <a href="http://www.rebol.cz/~cyphre/spell.r">Cyphre</a></li>
<li>Ruby: by <a href="http://www.ruby-forum.com/topic/104327">Brian Adkins</a></li>
<li>Scheme: by <a href="http://practical-scheme.net/wiliki/wiliki.cgi?Gauche%3aSpellingCorrection&amp;l=en">Shiro</a></li>
<li>Scheme: by <a href="http://scheme.dk/blog/2007/04/writing-spelling-corrector-in-plt.html">Jens Axel</a></li>
</ul>
<hr />
(с) <a href="http://norvig.com/">Питер Норвиг</a><br />
Перевод: <a href="http://gmdidro.googlepages.com">Петров Александр</a><br />
Оригинальный текст статьи Вы можете найти <a href="http://norvig.com/spell-correct.html">здесь</a>.
</body>
</html>
